[{"content":"My machine Alibaba Cloud: centos_7_9_x64_20G_alibase_20240628.vhd\nThe following commands are executed with root privileges.\nInstall docker-ce and docker-compose Use a mirror if the default url is not accessible.\nSet up the docker repository:\n1 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo Install docker and docker-compose with yum:\n1 yum install docker-ce docker-compose Start and enable docker:\n1 2 systemctl start docker systemctl enable docker Then check the status of docker:\n1 systemctl status docker Create the project directory 1 2 mkdir mailserver cd mailserver Prepare sql script I use MySQL to store the data of email accounts.\nmysql-init/init.sql:\n1 2 3 4 5 6 7 8 9 10 11 12 create database if not exists mailserver; use mailserver; create table if not exists user ( id int auto_increment primary key, email varchar(255) not null unique, password varchar(255) not null, active boolean default true ) engine=innodb; insert into user (email, password) values (\u0026#39;test@yourdomain.com\u0026#39;, \u0026#39;password\u0026#39;); Create docker-compose.yml Use MySQL, Postfix and Dovecot.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 version: \u0026#39;3\u0026#39; services: mysql: image: mysql:5.7 container_name: mail_mysql environment: MYSQL_ROOT_PASSWORD: examplepassword MYSQL_DATABASE: mailserver MYSQL_USER: root MYSQL_PASSWORD: examplepassword volumes: - ./data/mysql:/var/lib/mysql - ./mysql-init:/docker-entrypoint-initdb.d networks: - mailnetwork postfix: image: tvial/docker-mailserver:latest container_name: mail_postfix environment: MAIL_DOMAIN: mydomain.com MAIL_HOST: mail.mydomain.com MYSQL_HOST: mysql MYSQL_PORT: 3306 MYSQL_USER: root MYSQL_PASSWORD: examplepassword MYSQL_DB: mailserver MYSQL_USER_TABLE: user MYSQL_USER_FIELD: email MYSQL_PASSWORD_FIELD: examplepassword depends_on: - mysql ports: # - \u0026#34;25:25\u0026#34; # SMTP - \u0026#34;26:25\u0026#34; # use another port as the isp bans port 25 - \u0026#34;587:587\u0026#34; # Submission - \u0026#34;993:993\u0026#34; # IMAPS volumes: - ./data/postfix:/var/mail networks: - mailnetwork dovecot: image: dovecot/dovecot container_name: mail_dovecot environment: MYSQL_HOST: mysql MYSQL_PORT: 3306 MYSQL_USER: root MYSQL_PASSWORD: examplepassword MYSQL_DB: mailserver MYSQL_USER_TABLE: user MYSQL_USER_FIELD: email MYSQL_PASSWORD_FIELD: examplepassword depends_on: - mysql volumes: - ./data/dovecot:/var/mail networks: - mailnetwork networks: mailnetwork: driver: bridge volumes: mysql-data: Start docker-compose 1 docker-compose up -d Configure DNS and open required port DNS:\nA: mydomain.com -\u0026gt; server ip address A: mail.mydomain.com -\u0026gt; server ip address MX: mydomain.com -\u0026gt; mail.mydomain.com // Setting up firewall ports omitted\nTest Something went wrong:\n1 2 3 4 5 $ telnet mail.mydomain.com 26 Trying ${ip}... Connected to mail.mydomain.com. Escape character is \u0026#39;^]\u0026#39;. Connection closed by foreign host. Similar problem found on StackOverflow with no solutions\nAfter several struggles, I\u0026rsquo;m still unable to solve the problem.\nConclusion Maybe I will solve the problem later.\nWhatever, embrace the lessons from the journey and happy coding!\n","date":"2024-11-13T00:00:00Z","permalink":"http://localhost:1313/p/mailserver/","title":"An attempt to set up a mailserver, but ultimately failed"},{"content":" 平衡 忠诚 不息\n“银蓝” 首先名字就很好听，哈哈\u0026hellip;\n隔离变化与不变 在操作系统的日常使用中，底层内核往往保持稳定，上层应用变化较多。\n一般的系统中，上层应用在变化中可能破坏底层操作系统，接连影响到其他应用。最坏的情况是，上层应用导致操作系统内核损坏，从而整个系统崩溃。显然，原因是紧耦合。\n因此，解决方案是对变化与不变的隔离。Silverblue 具有不可变特性：操作系统的基础部分是只读的，保持稳定；应用的变化仅发生在上层，无法改变底层系统的核心，由此减少了系统损坏或崩溃的风险。\n容器化应用 除了少数最必要的包使用 rpm-ostree install 进行安装，大部分应用都使用容器化技术安装，例如 Flatpak, Toolbx, Podman，容器化技术在不可变的 Silverblue 系统上创建了可变、可管理的开发环境，并保证了应用之间的进一步隔离。\n另外，Toolbx 使各种工具能够整齐分类摆放，使工作空间保持整洁。\n无缝衔接的体验 除了不可变部分，Silverblue 的使用体验和 Workstation 极为相似。\n在 Toolbx 中，可以使用 dnf 安装应用，这一点应该能打消很多转变的疑虑。\n不要停止前进 在传统的操作系统中，面对前方的未知，前进由勇气驱动。Silverblue 则为勇气提供了保障。\nrpm-ostree 的版本控制机制能够切换和回滚到不同的系统版本，使用户能够大胆尝试新的版本；容器化应用则让用户不必担心对主系统产生不良影响。\n最后 Silverblue 的设计充满魅力，不要犹豫去使用！\n","date":"2024-11-06T00:00:00Z","permalink":"http://localhost:1313/p/silverblue/","title":"Hello Silverblue!"},{"content":"需求分析 业务无非 CRUD 设计一个业务时，思考与其他业务的关联 架构设计 模块的拆分 将不同的功能划分到不同的模块，在模块层面达到高内聚、低耦合 模块之间的调用 同层之间的模块可以通过同步接口调用 上下层系统之间可以使用消息中间件异步调用 模块内部 IoC/DI MVC DDD 类的设计 需要哪些类 MVC 的接口和实现类 POJO 工具类 \u0026hellip; 设计原则和设计模式 时刻考虑设计原则（SOLID、基于接口而非实现编程等） 思考哪些地方能用上设计模式，常用策略模式、模板方法模式、责任链模式 接口的设计 要符合接口隔离原则，粒度要小 在细粒度的接口外使用粗粒度的接口进行一次封装，给外部调用 功能设计 需要干啥就干啥 使用已有的专门的类，如线程池等 扩展、重构 添加新的功能以满足发展的业务需求 通过重构提高代码质量 ","date":"2024-10-17T00:00:00Z","permalink":"http://localhost:1313/p/oo-design-biz/","title":"面向对象设计（业务篇）"},{"content":" 笑问客从何处来\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.Objects; public class ExampleClass { private String privateField; public ExampleClass(String privateField) { this.privateField = privateField; } @Override public boolean equals(Object other) { return ((this == other) || (other instanceof ExampleClass that \u0026amp;\u0026amp; Objects.equals(this.privateField, that.privateField))); } } 这段代码能通过编译吗？ equals 方法中，使用 that.privateField 访问私有字段\n乍一看，Object other 通过方法参数传来，是外部对象，不能使用 . 直接访问私有字段，而应该使用 getter 方法\n实际上，此时 that 的类型就是 ExampleClass，在同一类中具有直接访问私有字段的权限，所以代码是正确的，可以通过编译\n致谢 感谢 @Sam Brannen 和 Spring 社区\n","date":"2024-09-30T00:00:00Z","permalink":"http://localhost:1313/p/access-private-field/","title":"访问权限控制情形：外来的对象回到了自己的类中"},{"content":"问题描述 git clone 一个项目后，使用 IDEA 打开，发现左侧项目目录中没有源代码所在目录，例如 src 缺失或者模块缺失\n具体步骤 首先：\nProject Structure -\u0026gt; modules -\u0026gt; + -\u0026gt; Import Module -\u0026gt; 选择项目根目录 -\u0026gt; (接着看文章)\n对于结构简单的项目，选择 Create module from existing sources 即可\n此时模块被导入，左侧目录中可以看到出现了各个模块\n但是，对于结构较为复杂（模块嵌套）的项目，上述做法会导致项目被拆散，即各个模块全部散出去\n于是，在选择根目录后，需要选择 Import module from external model，并选择项目对应的构建工具（例如 Maven），进行导入\n还没有结束，因为 pom.xml 变灰且被划横线\n解决方案：在 Settings -\u0026gt; Build, Execution, Deployment -\u0026gt; Build Tools -\u0026gt; Maven -\u0026gt; Ignored Files 中取消选择所有 pom.xml\n点击 Apply，发现点不动\u0026hellip;\n解决方案：点击 OK，通过 File -\u0026gt; Invalidate Caches 删除缓存，重启后项目恢复正常\n结语 为什么会出现这样的问题呢？可能是 IDEA 的 bug\n这个解决方案也是我摸索出来的，希望能帮到他人，不被业务以外的事情困扰\n","date":"2024-09-18T00:00:00Z","permalink":"http://localhost:1313/p/idea-src-missing/","title":"IDEA 左侧项目目录消失问题 解决方案"},{"content":" 每当仰望山巅，我就感到如坠深渊，于是我便开始攀登\n复用：初始的 MVC MiniSpring 使用 Tomcat 作为服务器，初始的 MVC 与 IoC 类似，可以复用 IoC 的代码\nbeans.xml：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;/url\u0026#34; class=\u0026#34;com.alioth4j.XxxClass\u0026#34; value=\u0026#34;methodName\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 与 Servlet 相关的 web.xml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;web-app xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:web=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\u0026#34; id=\u0026#34;WebApp_ID\u0026#34;\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.alioth4j.web.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;servletConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;/WEB-INF/servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; ClassPathXmlResource 复用 IoC 容器中的同名组件\nMappingValue 类似 BeanDefinition，XmlConfigReader 类似 XmlBeanDefinitionReader\nDispatcherServlet 类似初始 IoC 中的 ClassPathXmlApplicationContext\n其中 DispatcherServlet 需要 extends javax.servlet.http.HttpServlet 并重写 init 方法\n增强 MVC：组件扫描和注解支持 servlet.xml：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;components\u0026gt; \u0026lt;component-scan base-package=\u0026#34;com.alioth4j.xxx\u0026#34; /\u0026gt; \u0026lt;/components\u0026gt; @RequestMapping：\n1 2 3 4 5 6 7 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface RequestMapping { String value() default \u0026#34;\u0026#34;; } 工具类 XmlScanComponentUtil：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class XmlScanComponentUtil { public static List\u0026lt;String\u0026gt; getNodeValue(URL xmlPath) { List\u0026lt;String\u0026gt; packages = new ArrayList\u0026lt;\u0026gt;(); // dom4j SAXReader saxReader = new SAXReader(); Document document = null; try { document = saxReader.read(xmlPath); } catch (DocumentException e) { e.printStackTrace(); } Element root = document.getRootElement(); Iterator it = root.elementIterator(); while (it.hasNext()) { Element element = (Element) it.next(); packages.add(element.attributeValue(\u0026#34;base-package\u0026#34;)); } return packages; } } DispatcherServlet 中增加集合：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class DispatcherServlet extends HttpServlet { private List\u0026lt;String\u0026gt; packageNames = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;String\u0026gt; controllerNames = new ArrayList\u0026lt;\u0026gt;(); private Map\u0026lt;String, Class\u0026lt;?\u0026gt;\u0026gt; controllerClasses = new HashMap\u0026lt;\u0026gt;(); private Map\u0026lt;String, Object\u0026gt; controllerObjs = new HashMap\u0026lt;\u0026gt;(); private List\u0026lt;String\u0026gt; urlMappingNames = new ArrayList\u0026lt;\u0026gt;(); private Map\u0026lt;String, Object\u0026gt; mappingObjs = new HashMap\u0026lt;\u0026gt;(); private Map\u0026lt;String, Method\u0026gt; mappingMethods = new HashMap\u0026lt;\u0026gt;(); // ... } DispatcherServlet#init 中增加使用工具类获取要扫描的包名集合的操作，最后调用 refresh 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class DispatcherServlet extends HttpServlet { // ... @Override public void init(ServletConfig config) throws ServletException { super.init(config); // ... this.packageNames = XmlScanComponentHelper.getNodeValue(xmlPath); // ... refresh(); } // ... } DispatcherServlet#refresh：\n1 2 3 4 5 6 7 8 9 10 public class DispatcherServlet extends HttpServlet { // ... protected void refresh() { initController(); // 初始化 controller initMapping(); // 初始化 url 映射 } } DispatcherServlet#initController 装填 Controller 相关集合：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class DispatcherServlet extends HttpServlet { // ... protected void initController() { this.controllerNames = scanPackages(this.packageNames); for (String controllerName : this.controllerNames) { Class\u0026lt;?\u0026gt; clz = null; try { clz = Class.forName(controllerName); } catch (ClassNotFoundException e) { e.printStackTrace(); } this.controllerClasses.put(controllerName, clz); Object obj = null; try { obj = clz.newInstance(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } this.controllerObjs.put(controllerName, obj); } } } DispatcherServlet#initMapping 检查所有 Controller 的所有方法是否带有 @RequestMapping 注解，有的话加入到相关集合中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class DispatcherServlet extends HttpServlet { // ... protected void initMapping() { for (String controllerName : this.controllerNames) { Class\u0026lt;?\u0026gt; clazz = this.controllerClasses.get(controllerName); Object obj = this.controllerObjs.get(controllerName); Method[] methods = clazz.getDeclaredMethods(); if (methods != null) { for (Method method : methods) { boolean isRequestMapping = method.isAnnotationPresent(RequestMapping.class); if (isRequestMapping){ String methodName = method.getName(); String urlmapping = method.getAnnotation(RequestMapping.class).value(); this.urlMappingNames.add(urlmapping); this.mappingObjs.put(urlmapping, obj); this.mappingMethods.put(urlmapping, method); } } } } } } 使用递归根据包名获取所有 Controller 名称：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class DispatcherServlet extends HttpServlet { // ... private List\u0026lt;String\u0026gt; scanPackages(List\u0026lt;String\u0026gt; packageNames) { List\u0026lt;String\u0026gt; tempControllerNames = new ArrayList\u0026lt;\u0026gt;(); for (String packageName : packageNames){ tempControllerNames.addAll(scanPackage(packageName)); } return tempControllerNames; } private List\u0026lt;String\u0026gt; scanPackage(String packageName) { List\u0026lt;String\u0026gt; tempControllerNames = new ArrayList\u0026lt;\u0026gt;(); URL url = this.getClass().getClassLoader().getResource(\u0026#34;/\u0026#34; + packageName.replaceAll(\u0026#34;\\\\.\u0026#34;, \u0026#34;/\u0026#34;)); File dir = new File(url.getFile()); for (File file : dir.listFiles()) { if (file.isDirectory()) { scanPackage(packageName + \u0026#34;.\u0026#34; + file.getName()); } else { // -6 是去掉最后的 \u0026#34;.class\u0026#34; String controllerName = packageName + \u0026#34;.\u0026#34; + file.getName().substring(0, file.getName() - 6); tempControllerNames.add(controllerName); } } return tempControllerNames; } } 重写 doGet 方法，用于处理 Http Get 请求，从 HttpServletRequest 中取得请求路径，到集合中取得对应的对象，进行反射调用，最后把结果写回 HttpServletResponse：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class DispatcherServlet extends HttpServlet { // ... @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String sPath = request.getServletPath(); if (!this.urlMappingNames.contains(sPath)) { return; } Object obj = null; Object objResult = null; try { Method method = this.mappingMethods.get(sPath); obj = this.mappingObjs.get(sPath); objResult = method.invoke(obj); } catch (SecurityException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } response.getWriter().append(objResult.toString()); } } Servlet 规范：服务器的启动时序 读取 web.xml 中的配置 启动 Listener 启动 DispatcherServlet Spring 通过这个时序实现 MVC 的功能\n第一步，web.xml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:web=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/nx/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\u0026#34; id=\u0026#34;WebApp_ID\u0026#34;\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;com.alioth4j.web.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.alioth4j.web.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;servletConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;/WEB-INF/servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcherServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 第二步与第三步，先看 WebApplicationContext 家族\nWebApplicationContext 接口：\n1 2 3 4 5 6 7 8 public interface WebApplicationContext extends ApplicationContext { String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + \u0026#34;.ROOT\u0026#34;; ServletContext getServletContext(); void setServletContext(ServletContext servletContext); } Listener 和 DispatcherServlet 中是两级 WebApplicationContext，因此用两个实现类 XmlWebApplicationContext 和 AnnotationConfigWebApplicationContext 分别与之对应\n这两个 WebApplicationContext 的实现类 extends ClassPathXmlApplicationContext implements WebApplicationContext，由此将 IoC 和 MVC 关联起来\nXmlWebApplicationContext:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class XmlWebApplicationContext extends ClassPathXmlApplicationContext implements WebApplicationContext { private ServletContext servletContext; public XmlWebApplicationContext(String fileName) { super(fileName); } @Override public ServletContext getServletContext() { return this.servletContext; } @Override public void setServletContext(ServletContext servletContext) { this.servletContext = servletContext; } } AnnotationConfigWebApplicationContext：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 public class AnnotationConfigWebApplicationContext extends ClassPathXmlApplicationContext implements WebApplicationContext { private WebApplicationContext parentApplicationContext; private ServletContext servletContext; DefaultListableBeanFactory beanFactory; private final List\u0026lt;BeanFactoryPostProcessor\u0026gt; beanFactoryPostProcessors = new ArrayList\u0026lt;\u0026gt;(); public AnnotationConfigWebApplicationContext(String fileName) { this(fileName, null); } public AnnotationConfigWebApplicationContext(String fileName, WebApplicationContext parentApplicationContext) { this.parentApplicationContext = parentApplicationContext; this.servletContext = parentApplicationContext.getServletContext(); URL xmlPath = null; try { xmlPath = this.getServletContext().getResource(fileName); } catch (MalformedURLException e) { e.printStackTrace(); } List\u0026lt;String\u0026gt; packageNames = XmlScanComponentHelper.getNodeValue(xmlPath); List\u0026lt;String\u0026gt; controllerNames = scanPackages(packageNames); DefaultListableBeanFactory bf = new DefaultListableBeanFactory(); this.beanFactory = bf; this.beanFactory.setParent(this.parentApplicationContext.getBeanFactory()); loadBeanDefinitions(controllerNames); refresh(); } private void loadBeanDefinitions(List\u0026lt;String\u0026gt; controllerNames) { for (String controllerName : controllerNames) { String beanID = controllerName; String beanClassName = controllerName; BeanDefinition beanDefinition = new BeanDefinition(beanID, beanClassName); this.beanFactory.registerBeanDefinition(beanID, beanDefinition); } } private List\u0026lt;String\u0026gt; scanPackages(List\u0026lt;String\u0026gt; packageNames) { List\u0026lt;String\u0026gt; tempControllerNames = new ArrayList\u0026lt;\u0026gt;(); for (String packageName : packageNames){ tempControllerNames.addAll(scanPackage(packageName)); } return tempControllerNames; } private List\u0026lt;String\u0026gt; scanPackage(String packageName) { List\u0026lt;String\u0026gt; tempControllerNames = new ArrayList\u0026lt;\u0026gt;(); URL url = this.getClass().getClassLoader().getResource(\u0026#34;/\u0026#34; + packageName.replaceAll(\u0026#34;\\\\.\u0026#34;, \u0026#34;/\u0026#34;)); File dir = new File(url.getFile()); for (File file : dir.listFiles()) { if (file.isDirectory()) { scanPackage(packageName + \u0026#34;.\u0026#34; + file.getName()); } else { String controllerName = packageName + \u0026#34;.\u0026#34; + file.getName().replace(\u0026#34;.class\u0026#34;, \u0026#34;\u0026#34;); tempControllerNames.add(controllerName); } } return tempControllerNames; } @Override public ServletContext getServletContext() { return this.servletContext; } @Override public void setServletContext(ServletContext servletContext) { this.servletContext = servletContext; } @Override public ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException { return this.beanFactory; } } 因此第二步中的 Listener：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class ContextLoaderListener implements ServletContextListener { private static final String CONFIG_LOCATION_PARAM = \u0026#34;contextConfigLocation\u0026#34;; private WebApplicationContext context; public ContextLoaderListener() { } public ContextLoaderListener(WebApplicationContext context) { this.context = context; } @Override public void contextInitialized(ServletContextEvent event) { initWebApplicationContext(event.getServletContext()); } private void initWebApplicationContext(ServletContext servletContext) { String sContextLocation = servletContext.getInitParameter(CONFIG_LOCATION_PARAM); WebApplicationContext wac = new XmlWebApplicationContext(sContextLocation); wac.setServletContext(servletContext); this.context = wac; servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); } @Override public void contextDestroyed(ServletContextEvent event) { } } 第三步中的 DispatcherServlet：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class DispatcherServlet extends HttpServlet { public static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + \u0026#34;.CONTEXT\u0026#34;; private String servletConfigLocation; private WebApplicationContext parentApplicationContext; private WebApplicationContext webApplicationContext; // ... @Override public void init(ServletConfig config) throws ServletException { super.init(config); this.parentApplicationContext = (WebApplicationContext) this.getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); servletConfigLocation = config.getInitParameter(\u0026#34;servletConfigLocation\u0026#34;); URL xmlPath = null; try { xmlPath = this.getServletContext().getResource(servletConfigLocation); } catch (MalformedURLException e) { e.printStackTrace(); } this.packageNames = XmlScanComponentUtil.getNodeValue(xmlPath); this.webApplicationContext = new AnnotationConfigWebApplicationContext(servletConfigLocation, this.parentApplicationContext); refresh(); } // ... } 职责分离：抽取出 url 映射与反射调用代码 MappingRegistry 中存储集合：\n1 2 3 4 5 6 7 8 9 public class MappingRegistry { private List\u0026lt;String\u0026gt; urlMappingNames = new ArrayList\u0026lt;\u0026gt;(); private Map\u0026lt;String, Object\u0026gt; mappingObjs = new HashMap\u0026lt;\u0026gt;(); private Map\u0026lt;String, Method\u0026gt; mappingMethods = new HashMap\u0026lt;\u0026gt;(); // getter and setter omitted } HandlerMapping 用于找到对应的反射相关对象：\n1 2 3 4 5 public interface HandlerMapping { HandlerMethod getHandler(HttpServletRequest request) throws Exception; } 实现类 RequestMappingHandlerMapping：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 public class RequestMappingHandlerMapping implements HandlerMapping { WebApplicationContext wac; private final MappingRegistry mappingRegistry = new MappingRegistry(); public RequestMappingHandlerMapping(WebApplicationContext wac) { this.wac = wac; initMapping(); } protected void initMapping() { Class\u0026lt;?\u0026gt; clz = null; Object obj = null; String[] controllerNames = this.wac.getBeanDefinitionNames(); for (String controllerName : controllerNames) { try { clz = Class.forName(controllerName); } catch (ClassNotFoundException e1) { e1.printStackTrace(); } try { obj = this.wac.getBean(controllerName); } catch (BeansException e) { e.printStackTrace(); } Method[] methods = clz.getDeclaredMethods(); if (methods != null) { for (Method method : methods) { boolean isRequestMapping = method.isAnnotationPresent(RequestMapping.class); if (isRequestMapping) { String methodName = method.getName(); String urlmapping = method.getAnnotation(RequestMapping.class).value(); this.mappingRegistry.getUrlMappingNames().add(urlmapping); this.mappingRegistry.getMappingObjs().put(urlmapping, obj); this.mappingRegistry.getMappingMethods().put(urlmapping, method); } } } } } @Override public HandlerMethod getHandler(HttpServletRequest request) throws Exception { String sPath = request.getServletPath(); if (!this.mappingRegistry.getUrlMappingNames().contains(sPath)) { return null; } Method method = this.mappingRegistry.getMappingMethods().get(sPath); Object obj = this.mappingRegistry.getMappingObjs().get(sPath); HandlerMethod handlerMethod = new HandlerMethod(method, obj); return handlerMethod; } } 反射相关对象封装在 HandlerMethod 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class HandlerMethod { private Object bean; private Class\u0026lt;?\u0026gt; beanType; private Method method; private MethodParameter[] parameters; private Class\u0026lt;?\u0026gt; returnType; private String description; private String className; private String methodName; public HandlerMethod(Method method, Object obj) { this.setMethod(method); this.setBean(obj); } public Method getMethod() { return method; } public void setMethod(Method method) { this.method = method; } public Object getBean() { return bean; } public void setBean(Object bean) { this.bean = bean; } } HandlerAdapter 用于反射调用：\n1 2 3 4 5 public interface HandlerAdapter { void handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; } 具体实现类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class RequestMappingHandlerAdapter implements HandlerAdapter { WebApplicationContext wac; public RequestMappingHandlerAdapter(WebApplicationContext wac) { this.wac = wac; } @Override public void handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { handleInternal(request, response, (HandlerMethod) handler); } private void handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handler) { Method method = handler.getMethod(); Object obj = handler.getBean(); Object objResult = null; try { objResult = method.invoke(obj); } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) { e.printStackTrace(); } try { response.getWriter().append(objResult.toString()); } catch (IOException e) { e.printStackTrace(); } } } DispatcherServlet 中增加相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class DispatcherServlet extends HttpServlet { private HandlerMapping handlerMapping; private HandlerAdapter handlerAdapter; // ... @Override protected void service(HttpServletRequest request, HttpServletResponse response) { request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.webApplicationContext); try { doDispatch(request, response); } catch (Exception e) { e.printStackTrace(); } } protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerMethod handlerMethod = null; handlerMethod = this.handlerMapping.getHandler(processedRequest); if (handlerMethod == null) { return; } HandlerAdapter ha = this.handlerAdapter; ha.handle(processedRequest, response, handlerMethod); } } 增强 MVC：传入参数自动绑定 增强处为 RequestMappingHandlerAdapter 中反射调用之前，new 出 WebDataBinderFactory 对象，从 HandlerMethod 对象中获取方法参数，对每一个参数执行下列逻辑：\nWebDataBinderFactory#createBinder 得到对应参数的 WebDataBinder WebDataBinder#bind 方法首先将 request 中的参数转换成一个 PropertyValues 对象，之后调用 BeanWrapperImpl#setPropertyValues 方法 BeanWrapperImpl#setPropertyValues 中对每一个 propertyValues.getPropertyValues() 调用 setPropertyValue 方法 BeanWrapperImpl#setPropertyValue 去获取 PropertyEditor，优先获取自定义 PropertyEditor ，不存在再去获取默认的，接着转换参数类型，并借助内部类 BeanPropertyHandler 通过反射读写参数的值 PropertyEditorRegistrySupport 中分别存储默认和自定义 PropertyEditor，构造器中初始化默认 PropertyEditor，用户可以通过 registerCustomEditor 方法注册自定义 PropertyEditor\n增强 MVC：处理返回结果 返回结果分为两种，视图和 @ResponseBody\n增强处为 RequestMappingHandlerAdapter 中反射调用之后，判断 @ResponseBody 是否存在，进入对应逻辑\n@ResponseBody 反射的返回值进行序列化，写入 response 中即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class RequestMappingHandlerAdapter { // ... @Override protected ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) { // ... if (invocableMethod.isAnnotationPresent(ResponseBody.class)) { // 序列化 } else { // ... } // ... } } 视图 Model 本质上是一个 Map\nModelAndView 中的 view 可能为 View 对象，也可能为逻辑视图名（String）\nModelAndView：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class ModelAndView { private Map\u0026lt;String, Object\u0026gt; model = new HashMap\u0026lt;\u0026gt;(); private Object view; public ModelAndView() { } public ModelAndView(String viewName) { this.view = viewName; } public ModelAndView(View view) { this.view = view; } public ModelAndView(String viewName, Map\u0026lt;String, ?\u0026gt; modelData) { this.view = viewName; if (modelData != null) { addAllAttributes(modelData); } } public ModelAndView(View view, Map\u0026lt;String, ?\u0026gt; model) { this.view = view; if (model != null) { addAllAttributes(model); } } public ModelAndView(String viewName, String modelName, Object modelObject) { this.view = viewName; addObject(modelName, modelObject); } // ... } 没有 @ResponseBody 就认为返回的是视图，如果是 ModelAndView 直接返回，是 String 认为是逻辑视图名，构造出 ModelAndView 并返回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class RequestMappingHandlerAdapter { // ... @Override protected ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) { // ... ModelAndView mav = null; if (invocableMethod.isAnnotationPresent(ResponseBody.class)) { // 序列化 } else { if (returnObj instanceof ModelAndView) { mav = (ModelAndView) returnObj; } else if (returnObj instanceof String) { String viewName = (String) returnObj; mav = new ModelAndView(); mav.setViewName(viewName); } } return mav; } } 返回到 DispatcherServlet 中，调用 render 方法对视图进行渲染：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class DispatcherServlet extends HttpServlet { // ... protected void render(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception { Map\u0026lt;String, Object\u0026gt; modelMap = mv.getModel(); for (Map.Entry\u0026lt;String, Object\u0026gt; e : modelMap.entrySet()) { request.setAttribute(e.getKey(), e.getValue()); } String path = \u0026#34;/\u0026#34; + mv.getViewName() + \u0026#34;.jsp\u0026#34;; request.getRequestDispatcher(path).forward(request, response); } } 至此 MVC 完成\n","date":"2024-08-28T00:00:00Z","permalink":"http://localhost:1313/p/mini-spring-mvc/","title":"手写 MiniSpring 之 MVC"},{"content":" 每当仰望山巅，我就感到如坠深渊，于是我便开始攀登\n配置与代码分离：XML 在 XML 文件中配置 Bean，可以将应用程序的可变部分与固定的框架代码分开，增加框架的灵活性，同时便于后续框架的扩展。\n一个简单的例子：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;xxxid\u0026#34; class=\u0026#34;com.alioth4j.minispring.XxxClass\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 面向对象：XML 对应的 Java 类 框架代码中需要一个对应于 XML 配置文件的类，因此创建 ClassPathXmlResource，我们的 mini-spring 为了简便，在构造器中使用 dom4j 完成对 XML 文件的装载工作，实际上 Spring Framework 使用 ResourceLoader 加载资源。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ClassPathXmlResource { Document document; Element rootElement; Iterator\u0026lt;Element\u0026gt; elementIterator; // root element iterator public ClassPathXmlResource(String fileName) { SAXReader saxReader = new SAXReader(); URL xmlPath = this.getClass().getClassLoader().getResource(fileName); try { this.document = saxReader.read(xmlPath); this.rootElement = document.getRootElement(); this.elementIterator = this.rootElement.elementIterator(); } catch (DocumentException e) { e.printStackTrace(); } } } 策略模式：类的家族 对于同一项工作，由于上下文的不同，具体策略也不同。\n采用 Interface - Abstract Class - Class 模式 对每一种类的家族结构进行设计。以后所有的类都要遵循这个结构。\n例如 Resource 家族：\n1 2 3 public interface Resource {...} public abstract class AbstractResource implements Resource {...} public class ClassPathXmlResource extends AbstractResource {...} 面向对象：XML 解析后 Bean 对应的类 创建 BeanDefinition，用于描述一个 Bean 的元数据。这个类的属性与 \u0026lt;bean\u0026gt; 标签中的属性对应，并提供构造器和 getter、setter 方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class BeanDefinition { private String id; private String className; public BeanDefinition(String id, String className) { this.id = id; this.className = className; } // 省略 getter 和 setter } 单一职责原则：专注 Resource -\u0026gt; BeanDefinition 的类 专门的工作应该交给专门的类进行，同时一个类应该只有一个职责，职责分离以降低耦合。\n创建 XmlBeanDefinitionReader：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class XmlBeanDefinitionReader { SimpleBeanFactory simpleBeanFactory; public XmlBeanDefinitionReader(SimpleBeanFactory simpleBeanFactory) { this.simpleBeanFactory = simpleBeanFactory; } public void loadBeanDefinitions(Resource resource) { while (resource.hasNext()) { Element element = (Element) resource.next(); String beanID = element.attributeValue(\u0026#34;id\u0026#34;); String beanClassName = element.attributeValue(\u0026#34;class\u0026#34;); BeanDefinition beanDefinition = new BeanDefinition(beanID, beanClassName); this.simpleBeanFactory.registerBeanDefinition(beanDefinition); } } } IoC 容器：创建和管理 Bean BeanFactory 接口：\n1 2 3 4 5 6 7 public interface BeanFactory { void registerBean(String beanName, Object obj); Object getBean(String beanName) throws BeansException; Boolean containsBean(String name); } BeanDefinitionRegistry 接口：\n1 2 3 4 5 6 7 8 public interface BeanDefinitionRegistry { void registerBeanDefinition(String name, BeanDefinition bd); BeanDefinition getBeanDefinition(String name); boolean containsBeanDefinition(String name); void removeBeanDefinition(String name); } SingletonBeanRegistry 接口：\n1 2 3 4 5 6 7 8 public interface SingletonBeanRegistry { void registerSingleton(String beanName, Object singletonObject); Object getSingleton(String beanName); boolean containsSingleton(String beanName); String[] getSingletonNames(); } DefaultSingletonBeanRegistry 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class DefaultSingletonBeanRegistry implements SingletonBeanRegistry { // 存放单例的集合 protected Map\u0026lt;String, Object\u0026gt; singletons = new ConcurrentHashMap\u0026lt;\u0026gt;(256); protected List\u0026lt;String\u0026gt; beanNames = new ArrayList\u0026lt;\u0026gt;(); public void registerSingleton(String beanName, Object singletonObject) { synchronized (this.singletons) { Object oldObject = this.singletons.putIfAbsent(beanName, singletonObject); if (oldObject != null) { throw new ... } this.beanNames.add(beanName); } } public Object getSingleton(String beanName) { return this.singletons.get(beanName); } public boolean containsSingleton(String beanName) { return this.singletons.containsKey(beanName); } public String[] getSingletonNames() { return (String[]) this.beanNames.toArray(); } protected void removeSingleton(String beanName) { synchronized (this.singletons) { this.beanNames.remove(beanName); this.singletons.remove(beanName); } } } SimpleBeanFactory 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class SimpleBeanFactory extends DefaultSingletonBeanRegistry implements BeanFactory, BeanDefinitionRegistry { // 存放 BeanDefinition 的集合 private Map\u0026lt;String, BeanDefinition\u0026gt; beanDefinitionMap = new ConcurrentHashMap\u0026lt;\u0026gt;(256); private List\u0026lt;String\u0026gt; beanDefinitionNames = new ArrayList\u0026lt;\u0026gt;(); public SimpleBeanFactory() { } // 容器的核心方法，暂时还没有使用三级缓存 public Object getBean(String beanName) throws BeansException { // 先尝试从直接 singletons 中直接拿 Bean 实例 Object singleton = this.getSingleton(beanName); // 没有则获取 BeanDefinition 创建实例 if (singleton == null) { BeanDefinition beanDefinition = beanDefinitions.get(beanName); if (beanDefinition == null) { throw new BeansException(\u0026#34;No such bean: \u0026#34; + beanName); } try { singleton = Class.forName(beanDefinition.getClassName()).newInstance(); } catch (ClassNotFoundException e) { e.printStackTrace(); } this.registerSingleton(beanName, singleton); } return singleton; } // Override methods omitted } 整合组件：容器的启动过程 ClassPathXmlApplicationContext：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ClassPathXmlApplicationContext implements BeanFactory { BeanFactory beanFactory; // Context 负责整合容器的启动过程 public ClassPathXmlApplicationContext(String fileName) { Resource resource = new ClassPathXmlResource(fileName); BeanFactory beanFactory = new SimpleBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory); reader.loadBeanDefinitions(resource); this.beanFactory = beanFactory; } // 对外提供一个 getBean 方法 @Override public Object getBean(String beanName) throws BeansException { return this.beanFactory.getBean(beanName); } // other Override methods omitted } 增强 IoC：构造器注入和 setter 注入 增加 XML 中标签和属性 ref 属性表示注入另一个 Bean\n1 2 3 4 5 6 7 8 9 \u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;id1\u0026#34; class=\u0026#34;com.alioth4j.minispring.ExampleClass1\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;id2\u0026#34; class=\u0026#34;com.alioth4j.minispring.ExampleClass2\u0026#34;\u0026gt; \u0026lt;!-- 构造器注入 --\u0026gt; \u0026lt;constructor-arg type=\u0026#34;String\u0026#34; name=\u0026#34;name\u0026#34; value=\u0026#34;value1\u0026#34; /\u0026gt; \u0026lt;!-- setter 注入 --\u0026gt; \u0026lt;property type=\u0026#34;int\u0026#34; name=\u0026#34;property\u0026#34; ref=\u0026#34;id1\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 增加对应的类 ArgumentValue（构造器注入）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class ArgumentValue { private String type; private String name; private Object value; private boolean isRef; public ArgumentValue(String type, String name, Object value, boolean isRef) { this.type = type; this.name = name; this.value = value; this.isRef = isRef; } // getter and setter omitted } PropertyValue（setter 注入）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class PropertyValue { private String type; private String name; private Object value; private boolean isRef; public PropertyValue(String type, String name, Object value, boolean isRef) { this.type = type; this.name = name; this.value = value; this.isRef = isRef } // getter and setter omitted } ArgumentValues（构造器注入）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ArgumentValues { private final List\u0026lt;ArgumentValue\u0026gt; argumentValueList = new ArrayList\u0026lt;\u0026gt;(); public ArgumentValues() { } public void addArgumentValue(ArgumentValue argumentValue) { this.argumentValueList.add(argumentValue); } // ... } PropertyValues（setter 注入）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class PropertyValues { private final List\u0026lt;PropertyValue\u0026gt; propertyValueList = new ArrayList\u0026lt;\u0026gt;(); public PropertyValues() { } public void addPropertyValue(PropertyValue pv) { this.propertyValueList.add(pv); } // ... } BeanDefinition 中增加属性 1 2 3 4 5 6 7 8 9 10 public class BeanDefinition { // ... private ArgumentValues constructorArgumentValues; private PropertyValues propertyValues; // ... } XmlBeanDefinitionReader 中增加解析过程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class XmlBeanDefinitionReader { // ... public void loadBeanDefinitions(Resource resource) { while (resource.hasNext()) { // 对应一整个 \u0026lt;bean\u0026gt; 标签 Element element = (Element) resource.next(); // \u0026lt;bean\u0026gt; 内的属性 String beanID = element.attributeValue(\u0026#34;id\u0026#34;); String beanClassName = element.attributeValue(\u0026#34;class\u0026#34;); BeanDefinition beanDefinition = new BeanDefinition(beanID, beanClassName); // \u0026lt;bean\u0026gt; 中嵌套的标签 // \u0026lt;constructor-arg\u0026gt; List\u0026lt;Element\u0026gt; constructorElements = element.elements(\u0026#34;constructor-arg\u0026#34;); ArgumentValues avs = new ArgumentValues(); for (Element e : constructorElements) { String aType = e.attributeValue(\u0026#34;type\u0026#34;); String aName = e.attributeValue(\u0026#34;name\u0026#34;); String aValue = e.attributeValue(\u0026#34;value\u0026#34;); avs.addArgumentValue(new ArgumentValue(aType, aName, aValue)); } beanDefinition.setConstructorArgumentValues(avs); // \u0026lt;property\u0026gt; List\u0026lt;Element\u0026gt; propertyElements = element.elements(\u0026#34;property\u0026#34;); PropertyValues pvs = new PropertyValues(); List\u0026lt;String\u0026gt; refs = new ArrayList\u0026lt;\u0026gt;(); for (Element e : propertyElements) { String pType = e.attributeValue(\u0026#34;type\u0026#34;); String pName = e.attributeValue(\u0026#34;name\u0026#34;); String pValue = e.attributeValue(\u0026#34;value\u0026#34;); String pRef = e.attributeValue(\u0026#34;ref\u0026#34;); String pV = \u0026#34;\u0026#34;; boolean isRef = false; if (pValue != null \u0026amp;\u0026amp; !pValue.equals(\u0026#34;\u0026#34;)) { isRef = false; pV = pValue; } else if (pRef != null \u0026amp;\u0026amp; !pRef.equals(\u0026#34;\u0026#34;)) { isRef = true; pV = pRef; refs.add(pRef); } pvs.addPropertyValue(new PropertyValue(pType, pName, pValue, isRef)); } beanDefinition.setPropertyValues(pvs); beanDefinition.setDependsOn(refs.toArray(new String[0])); this.beanFactory.registerBeanDefinition(beanID, beanDefinition); } } } SimpleBeanFactory#getBean 进行注入 为了解决循环依赖问题，使用三级缓存（具体是第二级缓存解决了 setter 注入的循环依赖问题）：\n第一级缓存：singletonObjects - 完全创建好的单例 Bean 实例\n第二级缓存：earlySingletonObjects - 早期的未完全初始化（尚未填充属性）的 Bean 实例\n第三级缓存：objectFactories - 创建 Bean 的工厂对象\n在 MiniSpring 中，第三级缓存使用 BeanDefinition + 反射 直接创建 Bean\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 public class SimpleBeanFactory extends DefaultSingletonBeanRegistry implements BeanFactory, BeanDefinitionRegistry { private Map\u0026lt;String, BeanDefinition\u0026gt; beanDefinitionMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); private List\u0026lt;String\u0026gt; beanDefinitionNames = new ArrayList\u0026lt;\u0026gt;(); // 二级缓存 private final Map\u0026lt;String, Object\u0026gt; earlySingletonObjects = new HashMap\u0026lt;\u0026gt;(16); public SimpleBeanFactory() { } /** * 激活 IoC 容器 */ public void refresh() { for (String beanName : beanDefinitionNames) { try { getBean(beanName); } catch (BeansException e) { e.printStackTrace(); } } } @Override public Object getBean(String beanName) throws BeansException { Object singleton = this.getSingleton(beanName); if (singleton == null) { singleton = this.earlySingletonObjects.get(beanName); if (singleton == null) { BeanDefinition bd = this.beanDefinitionMap.get(beanName); singleton = createBean(bd); this.registerBean(beanName, singleton); // BeanPostProcessor // step1: postProcessBeforeInitialization // step2: afterPropertiesSet // step3: init-method // step4: postProcessAfterInitialization } } if (singleton == null) { throw new BeansException(\u0026#34;No such bean: \u0026#34; + beanName); } return singleton; } private Object createBean(BeanDefinition bd) { Object obj = doCreateBean(bd); // 放入earlySingletonObjects中 this.earlySingletonObjects.put(bd.getId(), obj); Class\u0026lt;?\u0026gt; clz = null; try { clz = Class.forName(bd.getClassName()); } catch (ClassNotFoundException e) { e.printStackTrace(); } handleProperties(bd, clz, obj); return obj; } /** * 构造器注入创建Bean实例 * @param bd * @return */ private Object doCreateBean(BeanDefinition bd) { Class\u0026lt;?\u0026gt; clz = null; try { clz = Class.forName(bd.getClassName()); } catch (ClassNotFoundException e) { e.printStackTrace(); } Object obj = null; // 构造器注入相关 ArgumentValues argumentValues = bd.getConstructorArgumentValues(); if (!argumentValues.isEmpty()) { // 构造器注入 Class\u0026lt;?\u0026gt;[] paramTypes = new Class\u0026lt;?\u0026gt;[argumentValues.getArgumentCount()]; Object[] paramValues = new Object[argumentValues.getArgumentCount()]; for (int i = 0; i \u0026lt; argumentValues.getArgumentCount(); i++) { ArgumentValue argumentValue = argumentValues.getIndexedArgumentValue(i); if (\u0026#34;String\u0026#34;.equals(argumentValue.getType()) || \u0026#34;java.lang.String\u0026#34;.equals(argumentValue.getType())) { paramTypes[i] = String.class; paramValues[i] = argumentValue.getValue(); } else if (\u0026#34;Integer\u0026#34;.equals(argumentValue.getType()) || \u0026#34;java.lang.Integer\u0026#34;.equals(argumentValue.getType())) { paramTypes[i] = Integer.class; paramValues[i] = argumentValue.getValue(); } else if (\u0026#34;int\u0026#34;.equals(argumentValue.getType())) { paramTypes[i] = int.class; paramValues[i] = argumentValue.getValue(); } else { paramTypes[i] = String.class; paramValues[i] = argumentValue.getValue(); } } Constructor\u0026lt;?\u0026gt; con = null; try { con = clz.getConstructor(paramTypes); } catch (NoSuchMethodException e) { e.printStackTrace(); } try { obj = con.newInstance(paramValues); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } else { try { obj = clz.newInstance(); } catch (InstantiationException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } return obj; } /** * setter 注入相关 */ private void handleProperties(BeanDefinition bd, Class\u0026lt;?\u0026gt; clz, Object obj) { PropertyValues propertyValues = bd.getPropertyValues(); if (!propertyValues.isEmpty()) { // setter方法注入 for (int i = 0; i \u0026lt; propertyValues.size(); i++) { PropertyValue propertyValue = propertyValues.getPropertyValueList().get(i); String name = propertyValue.getName(); String type = propertyValue.getType(); Object value = propertyValue.getValue(); boolean isRef = propertyValue.getIsRef(); Class\u0026lt;?\u0026gt;[] paramTypes = new Class\u0026lt;?\u0026gt;[1]; Object[] paramValues = new Object[1]; if (!isRef) { if (\u0026#34;String\u0026#34;.equals(type) || \u0026#34;java.lang.String\u0026#34;.equals(type)) { paramTypes[0] = String.class; } else if (\u0026#34;Integer\u0026#34;.equals(type) || \u0026#34;java.lang.Integer\u0026#34;.equals(type)) { paramTypes[0] = Integer.class; } else if (\u0026#34;int\u0026#34;.equals(type)) { paramTypes[0] = int.class; } else { paramTypes[0] = String.class; } paramValues[0] = value; } else { try { paramTypes[0] = Class.forName(type); } catch (ClassNotFoundException e) { e.printStackTrace(); } try { paramValues[0] = getBean((String)value); } catch (BeansException e) { e.printStackTrace(); } } String methodName = \u0026#34;set\u0026#34; + name.substring(0, 1).toUpperCase() + name.substring(1); Method setter = null; try { setter = clz.getMethod(methodName, paramTypes); } catch (NoSuchMethodException e) { e.printStackTrace(); } try { setter.invoke(obj, paramValues); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } } // other methods omitted } 创建所有的 Bean SimpleBeanFactory 中添加 refresh 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class SimpleBeanFactory { // ... public void refresh() { for (String beanName : this.beanDefinitionNames) { try { getBean(beanName); } catch (BeansException e) { e.printStackTrace(); } } } // ... } 在 ClassPathXmlApplicationContext 中加上刷新相关代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ClassPathXmlApplicationContext { // ... public ClassPathXmlApplicationContext(String fileName, boolean isRefresh) { Resource resource = new ClassPathXmlResource(fileName); SimpleBeanFactory simpleBeanFactory = new SimpleBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(simpleBeanFactory); reader.loadBeanDefinitions(resource); this.beanFactory = simpleBeanFactory; if (isRefresh) { this.beanFactory.refresh(); } } // ... } 增强 IoC：注解注入 使用 BeanPostProcessor，反射获取类上所有属性，逐个判断有没有 @Autowired 注解，如果有，从 BeanFactory 中获取要注入的 Bean 实例，使用反射注入。\n@Autowired 注解 1 2 3 4 @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface Autowired { } BeanPostProcessor 家族 BeanPostProcessor：\n1 2 3 4 5 6 7 public interface BeanPostProcessor { Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException; void setBeanFactory(BeanFactory beanFactory); } AutowiredAnnotationBeanPostProcessor：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class AutowiredAnnotationBeanPostProcessor implements BeanPostProcessor { private BeanFactory beanFactory; public BeanFactory getBeanFactory() { return beanFactory; } @Override public void setBeanFactory(BeanFactory beanFactory) { this.beanFactory = beanFactory; } @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { Field[] fields = bean.getClass().getDeclaredFields(); if (fields != null) { for (Field field : fields) { boolean isAutowired = field.isAnnotationPresent(Autowired.class); if (isAutowired) { String fieldName = field.getName(); Object autowiredObj = this.getBeanFactory().getBean(fieldName); field.setAccessible(true); try { field.set(bean, autowiredObj); } catch (IllegalAccessException e) { e.printStackTrace(); } } } } return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { return null; } } BeanFactory 家族 原来的 SimpleBeanFactory 变为 AbstractBeanFactory，目的是把 postProcess 相关的两个方法作为抽象方法交给具体实现类实现（模板方法模式）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public abstract class AbstractBeanFactory { // ... @Override public Object getBean(String beanName) throws BeansException { Object singleton = this.getSingleton(beanName); if (singleton == null) { singleton = this.earlySingletonObjects.get(beanName); if (singleton == null) { BeanDefinition bd = this.beanDefinitionMap.get(beanName); singleton = createBean(bd); this.registerBean(beanName, singleton); // BeanPostProcessor // step1: postProcessBeforeInitialization singleton = applyBeanPostProcessorsBeforeInitialization(singleton, beanName); // step2: afterPropertiesSet // step3: init-method if (bd.getInitMethodName() != null \u0026amp;\u0026amp; !bd.getInitMethodName().equals(\u0026#34;\u0026#34;)) { invokeInitMethod(bd, singleton); } // step4: postProcessAfterInitialization applyBeanPostProcessorsAfterInitialization(singleton, beanName); this.removeSingleton(beanName); this.registerBean(beanName, singleton); } } if (singleton == null) { throw new BeansException(\u0026#34;No such bean: \u0026#34; + beanName); } return singleton; } public abstract Object applyBeanPostProcessorsBeforeInitialization(Object singleton, String beanName); public abstract Object applyBeanPostProcessorsAfterInitialization(Object singleton, String beanName); // ... } AutowireCapableBeanFactory：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class AutowireCapableBeanFactory extends AbstractBeanFactory { private final List\u0026lt;AutowiredAnnotationBeanPostProcessor\u0026gt; beanPostProcessors = new ArrayList\u0026lt;\u0026gt;(); @Override public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException { Object result = existingBean; for (AutowiredAnnotationBeanPostProcessor beanProcessor : getBeanPostProcessors()) { beanProcessor.setBeanFactory(this); result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) { return result; } } return result; } @Override public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException { Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) { result = beanProcessor.postProcessAfterInitialization(result, beanName); if (result == null) { return result; } } return result; } public List getBeanPostProcessors() { return this.beanPostProcessors; } public void addBeanPostProcessor(AutowiredAnnotationBeanPostProcessor beanPostProcessor) { this.beanPostProcessors.remove(beanPostProcessor); this.beanPostProcessors.add(beanPostProcessor); } // ... } ClassPathXmlApplicationContext 相关 refresh 方法中为当前 beanFactory new 一个 AutowiredAnnotationBeanPostProcessor 并注册：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ClassPathXmlApplicationContext { // ... public void refresh() throws BeansException, IllegalStateException { registerBeanPostProcessor(this.beanFactory); onRefresh(); } private void registerBeanPostProcessor(AutowireCapableBeanFactory beanFactory) { beanFactory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor()); } private void onRefresh() { this.beanFactory.refresh(); } } 接口隔离：拆分接口 拆分出 ListableBeanFactory、ConfigurableBeanFactory，新增 ConfigurableListableBeanFactory\nAutowireCapableBeanFactory 改为接口，增加 AbstractAutowireCapableBeanFactory 替代原有实现\n扩展：更多支持 Environment ApplicationEvent BeansException \u0026hellip; 集成：应用上下文 ApplicationContext：\n1 2 3 4 5 6 public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, ConfigurableBeanFactory, ApplicationEventPublisher { // ... } 抽象类 AbstractApplicationContext、具体实现类 ClassPathXmlApplicationContext\n至此 IoC 容器完成\n","date":"2024-08-24T00:00:00Z","permalink":"http://localhost:1313/p/mini-spring-ioc/","title":"手写 MiniSpring 之 IoC"},{"content":"“通用”的来源——模板方法模式 模板方法模式（Template Method Pattern）定义了算法的骨架，并将一些步骤的具体实现延迟到子类中，以允许子类在不改变算法结构的情况下重新定义算法的某些步骤。\n在 Spring Boot 中集成组件有一个通用过程，其中每一个步骤由用户自己实现，这就是模板方法模式的应用。\n\u0026ldquo;通用\u0026quot;的骨架—— IoC 容器 IoC 容器提供了模板方法模式中“算法的骨架” 控制反转是 Spring Boot 集成其它组件的核心 通用集成过程 引入依赖 pom.xml（Maven）或 build.gradle（Gradle）文件中添加所需组件的依赖\n环境配置 四种方式：\napplication.properties application.yml 环境变量 启动选项（命令行参数） 自定义配置类 @Configuration\n自定义组件 // 此“组件”指：所引入依赖中的一个部件\n@Component + 继承原有抽象组件，实现自定义组件\n注入组件，调用 API 集成完成，可以开始使用了\n总结 IoC 容器既提供对组件集成的支持，又为通用的集成流程制定了骨架。\n对不同组件的集成能够有一个通用的集成过程，得益于模板方法模式。\n","date":"2024-08-16T00:00:00Z","permalink":"http://localhost:1313/p/spring-boot-components-integration-process/","title":"Spring Boot 组件集成流程"},{"content":" 檐上踏月客，屏息听完莫入迷\n介绍 VMware 的论文《The Design of a Practical System for Fault-Tolerant Virtual Machines》中提出了一种以主备复制进行故障容错的系统设计，这个容错机制用于在出现单点故障等情况下保障系统的可用性\n基础架构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 │ │ ┌──────────────────┐ ┌──────────────────┐ ┌──────────┐ │ │ ┌────────────┐ │ logging channel │ ┌───────────┐ │ │ │ │ │ │ Primary VM ┼──┼─────────────────┼──► Backup VM │ │ │ Client ┼───┼────► └────────────┘ │ │ └───────────┘ │ │ │ │ │ │ │ │ └──────────┘ │ │ Physical server │ │ Physical server │ │ │ │ │ │ │ └────────┬─────────┘ └─────────┬────────┘ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ ┌─────────────────┐ │ │ │ │ │ │ │ └──────────┤ Shared disk ┼────────┘ │ │ └─────────────────┘ 两台虚拟机，primary 和 backup，分别运行在两台物理机器上 primary 和 backup 共享磁盘 client 只与 primary 进行交互，目标是让 client 认为（就像是）只有一台机器，对容错毫不知情 状态机与确定性重放 如果初始状态相同，在确定性系统中以相同顺序执行相同的指令，那么结束状态也相同 primary 与 backup 初始状态相同，backup 执行与 primary 相同的指令，这能够保证 primary 与 backup 的一致性。 主备之间的通信 primary 和 backup 分别有一块 log buffer primary 将指令写入自己的 log buffer，通过 logging channel 发送给 backup，backup 将指令从网络中接收到自己的 log buffer 中后回复 ACK 输出机制 primary 执行指令并产生输出； backup 只是执行指令，不产生输出 只有当 primary 接收到 backup 回复的 ACK 后，才向 client 输出 注意：性能问题\n优化1：面对读请求，primary 是否无需等待？ 优化2：应用层的处理机制 故障转移 当 primary 出现故障，由 backup 接管 primary 的工作，而 client 毫不知情 防止脑裂 共享磁盘支持一个原子的 test-and-set 操作，在 backup 接管之前进行这个操作，如果两个服务器都存活，这个操作就会失败，避免了脑裂 更多 磁盘发生故障时系统将无法继续提供服务，一种可行的解决方案是备份磁盘 复制状态机方法对于多 CPU 主机有局限性，VM-FT 经过多年的发展，从复制状态机方法转向状态转移方法，以提供对多 CPU 的支持 ","date":"2024-07-01T00:00:00Z","permalink":"http://localhost:1313/p/vm-ft/","title":"主备复制与故障容错系统设计"},{"content":"前言 Effective Java 作为 Java 四大名著之一，聚焦于 Java 语言习惯和高效的用法。EJ 告诉读者如何更好地构建代码，以便代码能够更好地工作；也便于其他人能够理解这些代码，便于修改和改善；程序也会因此变得更加令人愉快，更加优雅。\n全书共90条，接下来笔者将逐条进行总结。\n第1条：用静态工厂方法代替构造器 五大优势 有名称 不必每次创建一个新对象 可以返回原返回类型的任何自类型的对象 所返回的对象的类可以随方法的参数值而发生变化 所返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在 主要缺点 类如果不含public或者protected的构造器，就不能被子类化 程序员很难发现它们 第2条：遇到多个构造器参数时要考虑使用构建器 Builder 模式 第3条：用私有构造器或者枚举类型强化 Singleton 属性 实现 SIngleton 的三种方法 构造器私有，实例public static final 构造器私有，实例private static final，公有的成员是个静态工厂方法 单元素的枚举类型 第4条：通过私有构造器强化不可实例化的能力 企图用抽象类阻止实例化不可行，因为该类可以被子类化 副作用：使一个类不能被子类化，因为子类所有的构造器都必须调用超类的构造器 第5条：优先考虑依赖注入来引用资源 将资源传到构造器中，在构造器中初始化成员变量 第6条：避免创建不必要的对象 重用不可变对象 优先使用基本类型而不是装箱基本类型，避免不必要的自动装箱 第7条：消除过期的对象引用 警惕内存泄漏 第8条：避免使用终结方法和清除方法 它们不可预测，危险，一般情况下也不必要 第9条：try-with-resources 优先于 try-finally 在使用必须关闭的资源时 第10条：覆盖 equals 时请遵守通用约定 5个要求 自反性 对称性 传递性 一致性 非空性 第11条：覆盖 equals 时总要覆盖 hashCode 相等的对象必须具有相等的散列码 第12条：始终要覆盖 toString toString方法应该返回对象中的所有值得关注的信息 在文档中表明意图 第13条：谨慎地覆盖 clone 要确保不会伤害到原始的对象 实现了 Cloneble 接口的类都应该覆盖clone方法，先调用super.clone方法，再拷贝任何内部“深层结构”的可变对象 更好的办法是提供一个拷贝构造器或拷贝工厂 第14条：考虑实现 Comparable 接口 以便其实例可以被比较、排序、分类、搜索 比较时避免使用 \u0026lt; 和 \u0026gt; 操作符，而是使用装箱基本类型的静态compare方法，或者在 Comparator 接口中使用比较器的构造方法 第15条：使类和成员的可访问性最小化 封装 解耦 规则很简单：尽可能地使每个类或者成员不被外界访问 公有类的实例域决不能是公有的 public static final域所引用的对象要不可变 第16条：要在公有类中使用访问方法而非公有域 使用私有域和公有访问方法 对于可变的类，使用公有 setter 方法设置 第17条：使可变性最小化 不可变的类要遵循5条规则 不要提供任何会修改对象状态的方法 保证类不会被扩展 声明所有的域都是final的 声明所有的域都是private的 确保对于任何可变组建的互斥访问。如果有指向可变对象的域，必须确保客户端无法获得指向这些对象的的引用，并且不要用客户端提供的对象引用初始化这样的域 不可变对象是线程安全的，不需要同步，可以被自由的共享（不需要进行保护性拷贝） 如果类不能被做成不可变的，应该尽可能地限制它的可变性 构造器应该创建完全初始化的对象，并建立起所有的约束关系 第18条：复合优先于继承 复合：在一个新的类中增加一个私有域，引用现有类的一个实例。新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法（这被称为转发） 继承的问题：打破了封装性 第19条：要么设计继承并提供文档说明，要么禁止继承 如果方法调用到了可覆盖的方法，文档注释的末尾应该包含关于这些调用的描述信息 构造器决不能调用可被覆盖的方法 禁止子类化的2种办法 把类声明为final 所有构造器变为私有或者包级私有的，提供公有静态工厂替代构造器 第20条：接口优于抽象类 现有的类很容易被更新，以实现新的接口 接口是定义 mixin（混合类型）的理想选择 接口允许构造非层次结构的类型框架 但是，通过对接口提供一个抽象的骨架实现类，可以结合接口和抽象类的优点——模板方法模式\n接口负责定义类型，骨架实现类负责剩下的非基本类型接口方法 第21条：为后代设计接口 Java 8 中接口增加了缺省方法构造，可以给现有接口添加新方法而不破坏现有的实现，但是建议尽量避免 在发布前以不同的方式实现接口，进行测试 第22条：接口只用于定义类型 不应该使用常量接口。一个类在内部使用某些常量是实现细节，常量接口会把这样的实现细节泄露到该类的导出 API 中 第23条：类层次优于标签类 标签类过于冗长、容易出错，并且效率低下，应该用类层次来代替 第24条：静态成员类优于非静态成员类 如果嵌套类的实例可以在它的外围类的实例之外独立存在，这个嵌套类就必须是静态成员类 如果成员类的实例需要一个指向其外围实例的指针，就把成员类做成非静态的 第25条：限制源文件为单个顶级类 确保编译时一个类不会有多个定义 第26条：请不要使用原生态类型 使用原生态类型失掉了范型在安全性和描述性方面的所有优势 第27条：消除非受检的警告 如果无法消除警告，同时可以证明引起警告的代码是类型安全的，可以使用@SuppressWarnings(\u0026quot;unchecked\u0026quot;)注解 应该在尽可能小的范围内使用@SuppressWarnings(\u0026quot;unchecked\u0026quot;)注解。不要在整个类上使用这个注解，因为这么做可能会掩盖重要的信息 使用该注解要添加一条注释，说明为什么这么做是安全的 第28条：列表优于数组 数组和范型有着截然不同的类型规则：数组是协变且可以具体化的；范型是不可变的且可以被擦除的 范型数组是非法的，因为它不是类型安全的 第29条：优先考虑范型 使用范型比使用需要在客户端代码中进行转换的类型更加安全和容易 只要时间允许，就把现有的类型都范型化 第30条：优先考虑范型方法 类型参数的声明，处在方法的修饰符和返回值之间 第31条：利用有限制通配符来提升 API 的灵活性 例如：\u0026lt;? extends E\u0026gt; PECS 表示 producer-extends，consumption-super 所有的 comparable 和 comparator 都是消费者 第32条：谨慎并用范型和可变参数 可变参数是构建在顶级数组之上的一个技术露底，范型可变参数不是类型安全的 但是范型可变参数是合法的，在确保类型安全后，加上@SafeVarargs注解 第33条：优先考虑类型安全的异构容器 类型令牌：一个类的字面被用在方法中，来传达编译时和运行时的类型信息 集合 API 限制每个容器只能有固定数目的类型参数，可以通过将类型参数放在键上而不是容器上避开这一限制 例如：private Map\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(): 第34条：用 enum 代替 int 常量 枚举可读性更好，更加安全，功能更加强大 枚举中的属性与常量关联，方法的行为受该属性的影响 第35条：用实例域代替序数 序数：枚举的ordinal方法返回每个枚举常量在类型中的数字位置，可以从序数中得到关联的 int 值。但是这样难以维护：例如要添加一个与已经用过的 int 值关联的枚举常量。 永远不要根据枚举的序数导出与它关联的值，而是将它保存在一个实例域中 Enum 规范谈及ordinal方法：大多数程序员都不需要这个方法，它是用于像 EnumSet 和 EnumMap 这种基于枚举的通用数据结构的 第36条：用 EnumSet 代替位域 位域表示法的缺点 以数字形式打印时，翻译困难 遍历困难 编写 API 时需要先预测最多需要多少位，以选择对应的类型（不能超出位宽度） EnumSet 的优点 位域的简洁和性能优势 + 枚举类型的优点（第33条） EnumSet 的缺点 截止 Java 9，无法创建不可变的 EnumSet。但是这一点很可能在将来的版本中得到修正；现在可以用Collections.unmodifiableSet将 EnumSet 封装起来 第37条：用 EnumMap 代替序数索引 EnumMap 是专门用于枚举键的映射 如果关系是多维的，使用EnumMap\u0026lt;..., EnumMap\u0026lt;...\u0026gt;\u0026gt; 第38条：用接口模拟可扩展的枚举 枚举类型不是可扩展的，接口类型是可扩展的 第39条：注解优先于命名模式 命名模式：用于表明有些程序元素需要通过某种工具或者框架进行特殊处理 命名模式的缺点 文字拼写错误导致失败 无法确保它们只用于相应的程序元素上 没有提供将参数值与程序元素关联起来的好方法 大多数情况下不必自己定义注解类型，应该使用 Java 平台所提供的预定义的注解类型 第40条：坚持使用 Override 注解 原因 防止没能覆盖，而是重载了的情况 防止无意识的覆盖 第41条：用标记接口定义类型 标记接口：不包含方法声明的接口，它只是指明一个类实现了某种属性的接口 标记接口与标记注解 标记接口的优点：编译时的错误侦测；可以被更加精确地进行锁定；接口可以作为相关方法的类型参数 标记注解的优点：标记注解是更大的注解机制的一部分 何时使用标记注解、何时使用标记接口 如果标记是应用于任何程序元素而不是类或接口，就必须使用注解，因为只有类和接口可以实现或拓展接口 如果标记是广泛使用注解的框架的一个组成部分，使用标记注解 如果标记只用于类或接口，优先使用标记接口 第42条：Lambda 优点于匿名类 Lambda 的优势在于简洁 从 Java 8 开始，Lambda 成为表示小函数对象的最佳方式，打开了函数式编程的大门 删除所有 Lambda 参数的类型（除非能够使程序变得更加清晰） Lambda 没有名称和文档，如果一个计算本身不是自描述的，或者超出了几行（对于 Lambda 而言，一行最理想，三行是合理的最大极限），就不要把它放在 Lambda 中 尽可能不要序列化 Lambda 第43条：方法引用优先于 Lambda 方法引用能够得到更加简短、清晰的代码 如果 Lambda 太长或者过于复杂，可以从 Lambda 中提取代码放到一个新的方法中，并用该方法的引用代替 Lambda Lambda 和方法引用，哪个更加简洁就用哪个 第44条：坚持使用标准的函数接口 java.util.function 提供了大量标准的函数接口 函数接口用@FunctionalInterface注解标注 第45条：谨慎使用 Stream 滥用 Stream 会使程序代码更难以读懂和维护 避免使用 Stream 处理 char 值 使用 Stream pipeline，一旦将一个值映射到某个其他值，原来的值就丢失了 第46条：优先选择 Stream 中无副作用的函数 forEach 操作应该只用于报告 Stream 计算的结果，而不是执行计算 静态导入 Collectors 的所有成员，可以提升可读性 counting方法返回的收集器仅用作下游收集器。不应使用collect(counting())，因为Stream 的count方法有相同的功能。 第47条：Stream 要优先用 Collection 作为返回类型 对于公共的、返回序列的方法，Collection 或者适当的子类型通常是最佳的返回类型 如果无法返回集合，就返回 Stream 或者 Iterable 第48条：谨慎使用 Stream 并行 在 Stream 上获得的性能，最好是通过 ArrayList、HashMap、HashSet 和 ConcurrentHashMap 实例，数组，int 范围和 long 范围等。这些数据结构的共性是：都可以被精确、轻松地分成任意大小的子范围，使并行线程中的分工变得更加轻松；在进行顺序处理时，提供了优异的引用局部性（序列化的元素引用一起保存在内存中） Stream pipeline 的终止操作会影响并发执行的效率。并行的最佳终止操作是做减法，用一个 Stream 的reduce方法，将所有从 pipeline 产生的元素都合并在一起，或者预先打包像min、max、count和sum这类方法 如果是自己编写 Stream、Iterable 或者 Collection 实现，并且想要得到适当的并行性能，就必须覆盖spliterator方法，并广泛地测试结果 Stream 的并行性能 并行 Stream 不仅可能降低性能，包括活性失败、还可能导致结果出错，以及难以预计的行为（如安全性失败） 在适当的条件下，给 Stream pipeline 添加 parallel 调用，确实可以在多处理器核的情况下实现近乎线性的倍增 第49条：检查参数的有效性 在方法体的开头出检查参数 对于方法本身没有用到，却被保存起来供以后使用的参数，检验它们的有效性尤为重要（例如构造器的参数） 第50条：必要时进行保护性拷贝 假设类的客户端会近期所能来破坏这个类的约束条件，因此必须保护性地设计程序，进行保护性拷贝 保护性拷贝是在检查参数有效性之前进行的，并且有效性检查是针对拷贝之后的对象，这样做可以避免在“危险阶段”期间从一个线程改变类的参数 对于参数类型可以被不信任方子类化的参数，不要使用clone方法进行保护性拷贝 只要有可能都应该使用不可变的对象作为对象内部的组件，这样就不必保护性拷贝了 第51条：谨慎设计方法签名 方法的名称遵循标准的命名习惯 不要过于追求提供便利的方法，只有当一项操作被经常用到的时候，才考虑为它提供快捷方式 避免国产规定参数列表，尤其是相同类型的长参数序列 缩短过长的参数列表的技巧 把一个方法分解成多个方法 创建辅助类，用来保存参数的分组，辅助类一般为静态成员类 从对象构建到方法调用都采用Builder模式 对于参数类型，要优先使用接口而不是类 对于 boolean 参数，要优先使用两个元素的枚举类型 第52条：慎用重载 重载不一定执行“最为具体的方法”，调用的是哪个重载方法在编译时作出决定 可以用单个方法替换多个重载方法，并在这个方法中做一个显示的instanceof 安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法 可以给方法起不同的名称，而不使用重载机制 不要在相同的参数位置调用带有不同函数接口的方法 第53条：慎用可变参数 可变参数方法接受0个或者多个指定类型的方法 在使用可变参数之前，要先包含所有必要的参数 性能问题：每次调用可变参数方法都会导致一次数组的分配和初始化 第54条：返回零长度的数组或者集合，而不是 null 如果返回 null，每次用到时都需要判断是否为 null，这样 API 更难以使用，也更容易出错 通过重复返回同一个不可变的零长度集合避免分配的执行，防止损害程序的性能 第55条：谨慎返回 optional Optional 本质上与受检异常相类似，因为它们强迫 API 用户面对没有返回值的现实 Optional#isPresent()方法，当 optional 中包含一个值时返回 true，当 optional 为空时，返回 false 容器类型不应该被包装在 optional 中 使用 OptionalInt、OptionalLong 和 OptionalDouble，而不是基本包装类型的 optional optional 不适合作为键、值，或者集合或数组中的元素 不要将 optional 用作返回值以外的任何其他用途 第56条：为所有导出的 API 元素编写文档注释 在每个被导出的类、接口、构造器、方法和域声明之前增加一个文档注释 简洁地描述出它和客户端之间的约定 文档注释在源代码和产生的文档中都应该是易于阅读的 同一个类或接口中的两个成员或者构造器，不应该具有同样的概要描述 为泛型或者方法编写文档时，要说明所有的参数类型 为枚举类型编写文档时，要说明常量 为注解类型编写文档时，要说明所有成员 在文档中说明线程安全级别 Javadoc 具有“继承”方法注释的能力。如果一个 API 元素没有文档注释，Javadoc 会搜索最为适用的文档注释 文档注释中允许 HTML 标签，但是 HTML 元字符需要转义 第57条：将局部变量的作用域最小化 在第一次要使用它的地方进行声明 每一个局部变量的声明都应该包含一个初始化表达式（例外：一个变量的声明需要在 try 块内，但是变量在 try 块外要被用到，就要在 try 块之前声明，却不能被“有意义地初始化”） 如果在循环终止之后不再需要循环变量，for 循环优先于 while 循环（while 循环复制粘贴后可能会忘记改变迭代器） 使方法小而集中，将大方法拆分成多个小方法 第58条：for-each 循环优先于传统的 for 循环 迭代器和索引变量的使用可能会出错 无法使用 for-each 循环的情况 解构过滤——遍历时删除集合中的某些元素 转换——遍历列表或数组，并取代某些元素值 平行迭代——并行地遍历多个集合 第59条：了解和使用类库 类库的代码可能比你自己编写的代码更好一些，并且会随着时间的推移而不断改进 不要重复发明轮子！ 第60条：如果需要精确的答案，请避免使用 float 和 double float 和 double 执行的是二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的，但是它们没有提供完全精确的结果 float 和 double 不能用于货币计算，应使用 BigDecimal、int 或者 long 使用 BigDecimal 的好处除了精确，还有可以控制舍入（8种舍入模式） 第61条：基本类型优先于装箱基本类型 对装箱基本类型使用==操作符几乎总是错误的 当一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱。如果 null 被自动拆箱，就会抛出 NullPointerException 异常 何时使用装箱基本类型 作为集合中的元素 作为类型参数 反射的方法调用 第62条：如果其他类型更加合适，则尽量避免使用字符串 字符串不适合代替其他的值类型 字符串不适合代替枚举类型 字符串不适合代替聚合类型 字符串不适合代替能力表 第63条：了解字符串连接的性能 使用+连接 n 个字符串，需要 n 的平方级的时间 大量的字符串连接操作，应使用StringBuilder#append 第64条：通过接口引用对象 用接口作为类型，决定更换实现时，只需要改变构造器中实现类的名称（或者使用一个不同的静态工厂），程序将会更加灵活 如果没有合适的接口，则用类层次结构中提供了必要功能的最小的具体类引用对象 第65条：接口优先于反射机制 反射机制的缺点 损失了编译时类型检查的优势 代码有些笨拙和冗长 性能损失 应该怎么做 仅仅使用反射机制实例化对象，用编译时已知的某个接口或者超类访问对象 第66条：谨慎地使用本地方法 本地方法提供了“访问特定与平台的机制”的能力”，但是随着 Java 平台的不断成熟，Java 提供了越来越多以前只有在宿主平台上才拥有的特性，因此使用本地方法几乎没有必要 使用本地方法来提高性能的做法不知的提倡 本地方法的严重缺陷 本地方法不是安全的 本地方法不是可自由移植的 使用本地方法的应用程序更难调试 编写不便，阅读困难 第67条：谨慎地进行优化 不要进行优化！ 要努力编写好的程序而不是快的程序 在设计中就考虑到性能问题，努力避免限制性能的设计决策，而不是在系统完成后再改变某个基本方面，因为这样会破坏系统的结构 幸运的是，好的 API 设计也会带来好的性能——努力编写好的程序，速度自然会随之而来 试图做优化之前和之后，要对性能进行测量 第68条：遵守普遍接受的命名惯例 把标准的命名惯例当作一种内在的机制来看待，并把它们作为第二特性 包名为域名反写 类名大写驼峰 方法名、遍历名小写驼峰 常量全大写，下划线分隔 执行某个动作的方法用动词开头 返回 boolean 值的方法以 is 开头 返回被调用对象的一个非 boolean 属性的方法，用名词或者 getXxx 来命名 被废弃的 Java Beans 规范中：getXxx 和 setXxx 方法 toType、asType、typeValue 方法 静态工厂的常用名称：from、of、valueOf、instance、getInstance、newInstance、getType、newType 第69条：只针对异常的情况才使用异常 异常不应该用于正常的控制流 第70条：对可恢复的情况使用受检异常，对编程错误使用运行是异常 三种可抛出结构（throwable） 受检异常（checked exception） 运行时异常（run-time exception） 错误（error） 如果希望适当恢复，应使用受检异常。通过抛出受检异常，强迫调用者在一个 catch 子句中处理该异常，或者将它传播出去 大多数运行时异常表示前提违例（API 的客户端没有遵守 API 规范建立的约定） 错误表明资源不足、约束失败，或者其他使程序无法继续执行的条件。不应该定义 Error 的子类，也不应该抛出 AsserionError 异常 永远不应该抛出一个不是 Exception、RuntimeException 或 Error 的子类，否则会困扰用户 第71条：避免不必要地使用受检异常 受检异常强迫程序员处理异常的条件（在 catch 块中处理或抛出去），这是一种负担 消除受检异常的方法 返回 optional 把抛出异常的方法，分为两个方法，第一个方法返回一个 boolean 值，使用 if-else 语句执行方法或处理异常 第72条：优先使用标准的异常 不要直接使用 Exception、RuntimeException、Throwable、Error，对待它们就像对待抽象类一样 按照具体场景选定抛出的异常 第73条：抛出与抽象对应的异常 异常转译：更高层的实现捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常 第74条：每个方法抛出的所有异常都要建立文档 始终要单独地声明受检异常，并且利用 Javadoc 的 @throws 标签记录抛出异常的条件（这也帮助区分受检异常和非受检异常） main 方法可以被安全地声明抛出 Exception，因为它只通过虚拟机调用 第75条：在细节消息中包含失败-捕获信息 异常的细节信息应该包含“对该异常有贡献”的所有参数或域的值 为了安全，不要在细节消息中包含密码等信息 可以在构造器中引入细节消息 第76条：努力使失败保持原子性 失败原子性：失败的方法调用应该使对象保持在被调用之前的状态 失败原子性实现方式 1, 设计不可变对象\n2. 在执行操作之前检查参数的有效性\n3. 调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前的发生\n4. 在对象的一份临时拷贝上执行操作，操作完成后再代替原本的对象\n5. 编写恢复代码\n错误通常是不可恢复的，因此抛出 AssertionError 时不需要保持失败原子性 如果无法保证失败原子性，API 文档应该指明对象会处于什么状态 第77条：不要忽略异常 忽略异常：使用空的 catch 块 空的 catch 块会使异常达不到应有的目的 如果要忽略，catch 块中应该包含一条说明注释，并且异常变量命名为 ignored 第78条：同步访问共享的可变数据 synchronized 读写都要被同步 最好使用不共享的可变的数据（将可变数据限制在单个线程中） 第79条：避免过度同步 为了避免死锁和数据破坏，不要再同步区域内部调用外来方法 在同步区域内做尽可能少的工作 过度同步会失去并行的机会 第80条：executor、task 和 stream 优先于线程 更加简单就能享受到性能优势 第81条：并发工具优先于 wait 和 notify 正确地使用 wait 和 notify 比较困难 始终应该使用 wait 循环模式来调用 wait 方法；永远不要在循环之外调用 wait 方法 一种合理而保守的建议：始终使用 notifyAll 方法，不使用 notify 方法 并发工具：并发集合、Synchronizer、CountDownLatch 第82条：线程安全性的文档化 说明类的线程安全性级别 不可变 无条件的线程安全 有条件的线程安全 非线程安全 线程对立的 第83条：慎用延迟初始化 如果利用延迟初始化来破坏初始化的循环，就要使用同步访问方法 双重检查（两次检查域的值是否不为 null） 第84条：不要依赖于线程调度器 依赖线程调度器可能会导致不可移植 确保可运行的线程的平均数量不明显多于处理器的数量，使线程调度器没有耕读欧的选择，只能运行这些可运行的线程，直到它们不再可运行为止 如果线程没有在做有意义的工作，就不应该运行 不能通过 Thread.yield 来修正不能工作的程序 第85条：其他方法优先于 Java 序列化 序列化的攻击面过于庞大，无法进行防护，并且还在不断扩大 避免序列化攻击的最佳方式是永远不要反序列化任何东西 永远不要反序列化不被信任的数据 第86条：谨慎地实现 Serializable 接口 实现 Serializable 接口的代价 一旦一个类被发布，就大大降低了“该变这个类的实现”的灵活性（每个可序列化的类都有一个唯一标识号与之关联） 增加了出现 Bug 和安全漏洞的可能性（序列化机制是一种语言之外的对象创建机制） 第87条：考虑使用自定义的序列化形式 理想的序列化形式应该只包含该对象所表示的逻辑数据，而逻辑数据和物理表示法应该是各自独立的 一个对象的物理表示法和逻辑数据内容有实质性区别时，使用默认序列化形式的缺点 使类的导出 API 永远束缚在该类的内部表示法上 消耗过多的空间 消耗过多的时间 会引起栈溢出 第88条：保护性地编写 readObject 方法 readObject 方法可能会创建一个不可能的对象 保护性拷贝在有效性检查之前进行 第89条：对于实例控制，枚举类型优先于 readResolve 如果依赖 readResolve 进行实例控制，带有对象引用类型的所有实例域都必须声明为 transient 注意 readResolve 的可访问性 第90条：考虑用序列化代理代替序列化实例 序列化代理模式 为可序列化的类设计一个私有的静态嵌套类（序列化代理），精确地表示外围类的实例的逻辑状态。它有一个单独的构造器，参数类型就是外围类。构造器只从它的参数中复制数据：不需要进行任何一致性检查或者保护性拷贝。外围类和内部类都要实现 Serializable 接口\n","date":"2024-06-20T00:00:00Z","permalink":"http://localhost:1313/p/effective-java/","title":"Effective Java"},{"content":"MinIO中使用建造者模式构建方法的参数 例如：\n1 2 3 4 5 6 PutObjectArgs putObjectArgs = PutObjectArgs.builder() .bucket(BUCKET_NAME) .object(objectName) .contentType(file.getContentType()) .stream(file.getInputStream(), file.getSize(), ObjectWriteArgs.MIN_MULTIPART_SIZE).build(); minioClient.putObject(putObjectArgs); 将多个参数传入 () 中的问题 可读性较差\n一行代码过长，分多行也不够明确\n参数对应的是什么，需要记住或者 IDE 提示 可能导致错误重载\n见《Effective Java》第52条 违反开闭原则\n当需要新增、删除、修改参数时，需要修改方法签名 使用建造者模式构建方法参数的优点 提供了一种规范 方法入参唯一，是 methodNameArgs\n便于参数构建 链式调用清晰明了（编码、阅读、维护） 各个参数的设置可选择，提供了灵活性 符合开闭原则 需要新增、删除、修改参数时，不需要修改方法签名，只需要修改参数对应的类\n好处来源于解耦 方法与方法参数之间解耦\n","date":"2024-05-25T00:00:00Z","permalink":"http://localhost:1313/p/builder-parameter/","title":"建造者模式构建方法参数"},{"content":"简介 Tesseract 是一个开源 OCR 引擎，能将图像中的文本转换为可编辑的文本数据。\nTess4J 是基于 Java 的 Tesseract 的封装库，使 Java 开发者能够方便地利用 Tesseract 进行文本识别。\n环境配置 Linux 不需要环境配置，大多数 Linux 发行版中都包含 Tesseract。\nWindows 下载 Tesseract 安装包：https://digi.bib.uni-mannheim.de/tesseract/ 傻瓜式安装 配置环境变量（在系统变量中配置）\n变量名：TESSDATA_PREFIX\n变量值：downloadpath\\Tesseract-OCR\\tessdata 下载训练数据 下载训练数据（中文）：https://github.com/tesseract-ocr/tessdata_fast/blob/main/chi_sim.traineddata\n在这里也有其他版本：https://github.com/tesseract-ocr/tessdoc/blob/main/Data-Files.md 项目构建 pom.xml 文件中引入 tess4j 以及日志依赖 log4j.properties 作为 log4j 的配置文件 将训练数据文件复制到 src/main/resources/tess4j 文件夹中 src/main/resources 中放入需要进行 OCR 操作的图片 新建 Tess4JDemo 类，编写关键代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package com.alioth4j; import net.sourceforge.tess4j.Tesseract; import net.sourceforge.tess4j.TesseractException; import java.io.File; /** * Tess4j演示 * @author Alioth4J */ public class Tess4JDemo { public static void main(String[] args) { // 创建 File 对象表示要识别的图像文件 File imgFile = new File(\u0026#34;src/main/resources/example.png\u0026#34;); // 创建 Tesseract 对象 Tesseract tess = new Tesseract(); // 设置训练数据所在位置 tess.setDatapath(\u0026#34;src/main/resources/tess4j\u0026#34;); // 设置语言：英文 -\u0026gt; eng; 简体中文 -\u0026gt; chi_sim tess.setLanguage(\u0026#34;chi_sim\u0026#34;); // 字符串对象用于接收结果 String imgText = null; // 执行 OCR try { imgText = tess.doOCR(imgFile); } catch (TesseractException e) { e.printStackTrace(); } // 输出结果 System.out.println(\u0026#34;OCR 结果：\u0026#34;); System.out.println(imgText); } } 运行项目 运行 Tess4JDemo#main 方法即可 ","date":"2024-05-10T00:00:00Z","permalink":"http://localhost:1313/p/tess4j-demo/","title":"Tess4J 基础演示"}]